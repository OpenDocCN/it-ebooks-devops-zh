# Git 权威指南（Got Git）

## 前言

版本控制是管理数据变更的艺术，无论数据变更是来自同一个人，还是来自不同的人（一个团队）。版本控制系统不但要忠实地记录数据的每一次变更，还要能够帮助还原任何历史改动，以及实现团队的协同工作等。Git 就是版本控制系统中的佼佼者。

我对版本控制系统的兴趣源自于我在个人知识管理中的实践，其核心就是撰写可维护的文档，并保存于版本控制系统中。可维护文档的格式可以是 DocBook、FreeMind、reStructuredText 等。我甚至还对 FreeMind 加以改造以便让其文档格式更适合于版本控制系统，这就是我的第一个开源实践：托管于 SourceForge 上的 FreeMind-MMX 项目[[1]](#id11)。文档的书写格式问题解决之后，就是文档的存储问题了。通过版本控制系统，很自然地就可以实现对文档历史版本的保存，但是如何避免因为版本控制系统瘫痪而导致数据的丢失呢？Git 用其崭新的分布式的版本控制设计提供了最好的解决方案。使用 Git，我的知识库不再只有唯一的版本库与之对应，而是可以通过克隆操作分发到不同的磁盘或主机上，克隆的版本库之间通过推送（PUSH）和拉回（PULL）等操作进行同步，数据安全得到了极大的提升。在版本控制系统的忠实呵护下，我的知识库中关于 Git 的 FreeMind 脑图日积月累变得越来越详实，越来越清晰，最终成为这本书的雏形。

版本控制还能决定项目的成败，甚至是公司的生死，此言不虚。我在推广开源项目管理工具和为企业提供咨询服务的过程中，看到过太多的团队因为版本控制系统管理的混乱，导致项目延期、修正的 Bug 重现、客户的问题不能在代码中定位，无论他们使用的是什么版本控制系统，开源的或是商业的。这是因为传统的集中式版本控制系统不能有效地管理分支和进行分支间合并。集中管理的版本库只有唯一的分支命名空间，需要专人管理从而造成分支创建的不自由。分支间的合并要么因为缺乏追踪导致重复合并、引发严重冲突，要么因为蹩脚的设计导致分支合并时缺乏效率和陷阱重重。Git 用其灵活的设计让项目摆脱分支管理的梦魇。

我的公司也经历过代码管理的生死考验。因为公司的开发模式主要是基于开源软件的二次开发，最早在使用 SVN（Subversion）做版本控制时，很自然地使用了 SVN 卖主分支模型来管理代码。随着增加和修改的代码越来越多，和开源软件上游的偏离也越来越远，当上游有新版本发布时，最早可能只用几个小时就可以将改动迁移过去，但是如果对上游的改动多达几十甚至上百处时，迁移的过程就会异常痛苦，基本上和重新做一遍差不多。那时似乎只有一个选择：不再和上游合并，不再追踪上游的改动，而这与公司的价值观“发动全球智慧为客户创造价值”相违背。迷茫之中，分布式版本控制系统飘然而至，原来版本控制还可以这么做。

我最先尝试的分布式版本控制系统是 Hg（Mercurial），尤其是当发现 Hg 和 MQ（Hg 的一个插件）这一对儿宝贝的时候，我如获至宝。逐渐地，公司的版本库都迁移到了 Hg 上。但随着新的开发人员的加入，问题就出现了，即一个人使用 Hg 和 MQ 都很好，但多个人使用则会出现难以协同的问题。于是我们大胆地采用了 Git，并在实践中结合 Topgit 等工具进行代码的管理。再一次，也许是最后一次，我们的代码库迁移到了 Git。

最早认识分布式版本控制，源自于我们看到了众多开源项目的版本控制系统大迁移，这场迁移还在进行中。

*   MoinMoin 是我们关注的一个开源的维基软件，2006 年，它的代码库从 SVN 迁移到 Hg。[[2]](#id12)
*   Mailman 同样是我们关注的一个开源邮件列表软件。2007 年，它的代码库从 SVN 迁移到 Bazaar。[[3]](#id13)
*   Linux 采用 Git 做版本控制系统（一点都不奇怪，因为 Git 就是 Linus Torvalds 开发的）。
*   Android 是最为流行的开源项目之一，因为潜在的市场巨大，已经吸引越来越多的开发者进入这个市场，而 Android 就是用 Git 维护的。

当开源软件纷纷倒向分布式版本控制系统大旗（尤其是 Git）的时候，各个公司也在行动了，尤其是涉及异地团队协同，以及 Android 核心代码定制开发的公司。对于一些因保守而不敢向 Git 靠拢的公司，Git 也可以派上用场，这是因为 Git 可以和现在大多数公司部署的 SVN 很好地协同，即公司的服务器是 SVN，开发者的客户端则使用 Git。相信随着 Git 的普及，以及公司代码管理观念上的改进，会有更多的公司拥抱 Git。

### 本书的组织

本书正文共分为 8 篇，一共 41 章，还包括附录。

第 1 篇是 Git 的概览，共 3 章。第一章介绍了版本控制的历史。第二章用 10 来个小例子介绍了 Git 的一些闪亮特性，期待这些特性能够让您爱上 Git。第三章则介绍 Git 在三种主要的平台上的安装和使用。本书的写作过程中，70%的时间使用的是 Debian Linux 操作系统，Linux 用户可以毫无障碍地完成本书列举的所有相关操作。在 2010 年年底，当得知有出版社肯以稿酬支持本书的首印后，我向妻子阿巧预支了未来的部分稿费购买了我的第一台 MacBook Pro，于是本书就有了较为详实的 Mac OS X 下 Git 的安装和使用，以及在本书第 4 篇第二十二章介绍的 Topgit 在 Mac OS X 上的部署和改进。在本书的编辑和校对过程中因为要使用 Word 格式的文稿，所以本书后期的很多工作是在运行于 VirtualBox 下的 Windows 虚拟机中完成的，即使是使用运行于资源受限的虚拟机中的 Cygwin，Git 依然完美地完成了工作。

第 2 篇和第 3 篇详细介绍了 Git 的基本操作，是本书的基础和核心，篇幅大约占据了全书的 40%。这两篇的内容架构实际上是我在进行 SVN 培训时就已经形成的习惯，即以“独奏”指代一个人的版本控制所要讲述的知识点，以“和声”指代团队版本控制涉及的话题。在第 2 篇“Git 独奏”中将 Git 的设计原理穿插在各章之中，因为唯有了解 真相（Git 原理），才有可能自由（掌握 Git）。在第 3 篇“Git 和声”中，介绍团队版本控制必须掌握的里程碑和分支等概念，以及如何解决合并中遇到的冲突。

第 4 篇细致地讲解了在实际的工作中 Git 的使用模式。除了传统的集中式和分布式使用模式之外，第二十二章还介绍了 Topgit 在定制开发中的应用，这也是我公司使用 Git 最主要的模式。这一章还讲解了我对 Topgit 所做的部分改进，对相关改进的介绍最 早出现在我公司的博客上[[4]](#id14)。第 23-25 章介绍了多版本库协同的不同方法，其中第二十五章介绍的一个独辟蹊径的解决方案是由 Android 项目引入的名为 repo 的工具实现的，我对其进行的改造可以让这个工具能够脱离 Gerrit 代码审核服务器，直接操作 Git 服务器。第二十六章介绍了 git-svn 这一工具，该工具不但可以实现 SVN 版本库到 Git 版本库的迁移，还可以实现将 Git 作为客户端向 SVN 提交。

第 5 篇介绍 Git 服务器的架设。本篇是全书最早开始撰写的部分，这是因为我给客户做的 Git 培训讲义的相关部分不够详细，应客户要求对 Gitolite 等服务器架设撰写了详细的管理员手册，即本书的第三十章。第三十二章介绍了 Android 项目在 Git 管理上的又一大创造，即 Gerrit，它实现了一个独特的集中式 Git 版本库管理模型。

第 6 篇讲解了 Git 版本库的迁移。其中第三十四章详细介绍了 CVS 版本库到 Git 版本库的迁移，其迁移过程也可以作为 CVS 到 SVN 迁移的借鉴。本篇还介绍了 SVN 和 Hg 版本库到 Git 的迁移。对于其他类型的版本库，介绍了一个通用的需要编程来实现的方法。在本篇的最后还介绍了一个 Git 版本库整理的利器，可以理解为一个 Git 库转换为另外一个 Git 库的方法。

第 7 篇是关于 Git 的其他应用，其主要部分是介绍我在 etckeeper 启发下开发的一款备份工具 Gistore，该工具可以运行于 Linux 和 Mac OS X 下。

第 8 篇是 Git 杂谈。其中第四十章的内容可供跨平台的项目组借鉴。第四十一章介绍了一些前面没有涉及的 Git 相关功能和特性，缺少这些相关内容会有损于杨福川编辑为本书所取的宏大的书名。

第 9 篇是附录。首先介绍了完整的 Git 命令索引，然后分别介绍了 CVS、SVN、Hg 与 Git 之间的比较和命令对照，对于有着其他版本控制系统使用经验的用户，这一部分可供参考。

### 适用读者

这本书适合所有翻开它的人，因为我知道这本书在书店里一定被放在计算机图书专柜。

1.  为数据同步困扰的“电脑人”

困扰“电脑人”的一个问题是，有太多的数据需要长久保存，有太多的电脑设备需要数据同步。可能有的人会说：“像 Dropbox 一样的网盘可以帮助我呀”。是的，云存储就是在技术逐渐成熟之后应运而生的产品，但是依然解决不了如下几个问题：多个设备上同时修改造成的冲突；冗余数据传输造成的带宽瓶颈；没有实现真正的、完全的历史变更数据备份。具体参见本书第 7 篇第三十九章的内容。

Git 可以在数据同步上做得更好，甚至只须借助小小的 U 盘，就可以实现多台电脑数据同步，并且支持自动的冲突解决。只要阅读本书第 1 篇和第 2 篇，就能轻易掌握相关的操作，实现数据的版本控制和同步。

2.  学习计算机课程的学生

我非常后悔没有在学习编程的第一天就开始使用版本控制，很多还在学校时写的一些小程序和函数库都丢失了。在使用 CVS 和 SVN 对个人数据进行版本控制之后，才开始把每一天的变更历史都保留了下来。Git 在这方面可以比 CVS 和 SVN 等做得更好。

在阅读完本书的前 3 篇掌握了 Git 的基础之后，可以阅读第 5 篇第三十三章的内容，通过 GitHub 或类似的服务提供商建立自己的版本库托管，为自己的数据找一个安全的家。

3.  程序员

使用 Git 会让程序员有更多的时间休息，因为可以更快地完成工作。分布式版本控制让每一个程序员都在本地拥有一个完整的版本库，所以几乎所有操作都能够脱离网络执行而不受带宽的限制。加之使用了智能协议，让版本库间的同步不但减少了数据传输量，还能显示完成进度。

Git 会帮助程序员打开进入开源软件的大门，进而开阔视野，提升水平，增加择业的砝码。看看使用 Git 作为版本控制的开源软件吧：Linux kernel、Android、Debian、Fedora、GNOME、KDevelop、jQuery、Prototype、PostgreSQL、Ruby on Rails……不胜枚举。还有，不要忘了所有的 SVN 版本库都可以用 Git 方式更好地访问。

作为一个程序员，团队协同能力必不可少，本书第 3 篇应该作为学习的重点。

4.  Android 程序员

如果您是谷歌 Android 项目的参与者，尤其是驱动开发和核心开发的参与者，必然要接触 Git、repo 和 Gerrit。对于只是偶尔参考一下 Android 核心代码的 Android 应用开发人员，也需要对 repo 有深入的理解，这样才不致于每次为同步代码而花掉一天的时间。

repo 是 Android 为了解决 Git 多版本库管理问题而设计的工具，在本书第 4 篇第二十五章有详细介绍。

Gerrit 是谷歌为了避免因分布式开发造成项目分裂而创造的工具，打造了 Android 独具一格的集中式管理模式，在本书第 5 篇第三十二章有详细介绍。

即使是非 Android 项目，也可以使用这两款工具为自己的项目服务。我还为 repo 写了几个新的子命令以实现脱离 Gerrit 提交，让 repo 拥有更广泛的应用领域。

5.  定制开发程序员

当一个公司的软件产品需要针对不同的用户进行定制开发时，就需要在一个版本库中建立大量的特性分支，使用 SVN 的分支管理远不如用 Git 的分支管理那么自然和方便。还有一个领域就是对第三方代码进行维护。当使用 SVN 进行版本控制时，最自然的选择是卖主分支，而一旦定制开发愈加深入和上游的偏离也越大，和上游代码的合并也将越来越令人痛苦不堪。

第 4 篇第二十二章会介绍 Topgit 这一杀手级的工具，是这个领域最佳的解决方案。

6.  SVN 用户

商业软件的研发团队因为需要精细的代码授权不会轻易更换现有的 SVN 版本控制系统，这种情况下 Git 依然大有作为。无论是出差在外，或是在家办公，或是开发团队分处异地，都会遇到 SVN 版本控制服务器无法访问或速度较慢的情况。这时 git-svn 这一工具会将 Git 和 SVN 完美地结合在一起，既严格遵守了 SVN 的授权规定，又可以自如地进行本地提交，当能够连接到 SVN 服务器时，可以悠闲地喝着绿茶，等待一次性批量提交的完成。

我有几个项目（pySvnManager、Freemind-MMX）托管在 SourceForge 的 SVN 服务器上，现在都是先通过 git-svn 将其转化为本地的 Git 库，然后再使用的。以这样的方式访问历史数据、比较代码或提交代码再也不会因为网速太慢而望眼欲穿了。

本书第 4 篇第二十六章会向您详细介绍 Git 和 SVN 的互操作。

7.  管理员

Git 很大程度上减轻了管理员的负担：分支的创建和删除不再需要管理员统一管理，因为作为分布式版本控制系统每一个克隆就是一个分支，每一个克隆都拥有独立的分支命名空间；管理员也不再需要对版本库的备份操心，因为每一个项目成员都拥有一个备份。管理员也不必担心有人在服务器上篡改版本库，因为 Git 版本库的每一个对象（提交、文件等）都使用 SHA1 哈希值进行完整性校验，任何对历史数据的篡改都会因为对后续提交产生的连锁反应而原形毕露。

本书第 7 篇第三十七章介绍了一款我开发的基于 Git 的备份工具，让 Linux 系统的数据备份易如反掌。对于版本控制管理员，本书第 5 篇介绍的 Git 服务器搭建，以及第 6 篇介绍的版本库迁移，会为管理员的日常维护工作提供指引。

8.  开发经理

作为开发经理，您一定要对代码分支有深刻的理解，本书第十八章中的代码管理之殇，不知是否能引起您的共鸣。为了能在各种情况下恰当地管理开发团队，第 4 篇 Git 协同模型是项目经理关注的重点。您的团队是否存在着跨平台开发，或者潜在着跨平台开发的可能？本书第 8 篇第四十章也是开发经理应当关注的章节。

### 排版约定

本书使用下列排版格式约定：

1.  命令输出及示例代码

    执行一条 Git 命令及其输出的示例如下：

    ```
    $ git --version
    git version 1.7.4

    ```

2.  提示符（$）

    命令前面的`$`符号代表命令提示符，有时为了表示命令是在不同的主机上执行的，还在提示符的前面添加用户名或主机名。例如：

    ```
    client1$ hostname
    client1

    ```

3.  等宽字体（`Constant width`）

    用于表示代码、命令输出等内容。

4.  等宽粗体（`**Constant width bold**`）

    用于表示由用户手工输入的内容。

5.  等宽斜体（`*Constant width italic*`）

    用于表示正文中出现的命令、参数、文件名、函数名等。

6.  占位符（`<Constant width>`）

    用尖括号扩起来的内容，表示命令中或代码中的占位符。用户应当用实际值对其替换。

### 在线资源

*   官方网站：[`www.worldhello.net/gotgit/`](http://www.worldhello.net/gotgit/)
*   新浪微博：[`weibo.com/gotgit/`](http://weibo.com/gotgit/)

### 致谢

感谢 Linus Torvalds、Junio Hamano 和所有 Git 项目的贡献者，是他们带给我们崭新的版本控制使用体验。

本书能够出版要感谢华章出版社，华章对中文原创计算机图书的信任让每一个中国的计算机从业者都有可能一圆出书的梦想。做为一个新人，拿着一个新的选题，遇到同样充满激情的编辑，我无疑是幸运的，他就是华章的杨福川编辑。甚至没有向我要样章（那时本书已经过半），在看过目录之后，就冒险和我签约，他的激情让我不敢懈怠。同样要感谢华章的王晓菲编辑，她的耐心和细致让我吃惊，也正是因为她的工作能够让本书的行文更加流畅，让本书能够更快的问世。还有华章的张少波编辑，感谢她在接到我冒失的打给华章的电话后，帮我分析选题并推荐给其他编辑。

本书的内容是由我的 Git 培训讲义发展而来，再此感谢朝歌数码的蒋宗贵，是他的鼓励和鞭策让我完善了本书服务器架设的相关章节。还要感谢王谚宁，正是通过她的团队才让我认识了 Android，这才有了本书关于 repo 和 Gerrit 的相关章节。

感谢我的群英汇的同事们，尤其要感谢王胜，正是因为我们在使用 Topgit 0.7 版本时遇到了严重的冲突，才使我下定决心研究 Git。

本书的技术审校得到了中国科学院软件研究所的张先轶，比蒙科技的宋伯润和杨致伟，摩博科技的熊军，以及王胜等人的帮助，感谢他们为本书提供的宝贵意见和建议。来自台湾的 William Wu 纠正了本书对 Hg 认识上的偏颇，让本书附录中的相关内容更加准确和中立，在此向他表示感谢。

因为写书亏欠家人很多，直到最近才发现女儿小雪是多么的希望拥有一台儿童自行车。感谢妻子阿巧对我的耐心和对家庭的担当。感谢岳父、岳母几年来对小雪和我们整个家庭的照顾，让我没有后顾之忧。还要感谢我的父母和妹妹，他们对我事业的支持和鼓励是我前进的动力。在我写书的同时，老爸正在富春江畔代表哈尔滨电机厂监督发电机组的制造并也在写一本监造手册方面的书，抱歉老爸，我先完成了。:)

| [[1]](#id2) | [`sourceforge.net/projects/freemind-mmx/`](http://sourceforge.net/projects/freemind-mmx/) |

| [[2]](#id3) | [`moinmo.in/NewVCS`](http://moinmo.in/NewVCS) |

| [[3]](#id4) | [`wiki.list.org/display/DEV/Home`](http://wiki.list.org/display/DEV/Home) |

| [[4]](#id6) | [`blog.ossxp.com/`](http://blog.ossxp.com/) |

目录:

*   1\. 初识 Git
    *   1.1\. 版本控制的前世和今生
        *   1.1.1\. 黑暗的史前时代
            *   1.1.1.1\. 命令**diff**用于比较两个文本文件或目录的差异
            *   1.1.1.2\. 命令**patch**相当于**diff**的反向操作
        *   1.1.2\. CVS——开启版本控制大爆发
        *   1.1.3\. SVN——集中式版本控制集大成者
        *   1.1.4\. Git——Linus 的第二个伟大作品
    *   1.2\. 爱上 Git 的理由
        *   1.2.1\. 每日的工作备份
        *   1.2.2\. 异地协同工作
        *   1.2.3\. 现场版本控制
        *   1.2.4\. 避免引入辅助目录
        *   1.2.5\. 重写提交说明
        *   1.2.6\. 想吃后悔药
        *   1.2.7\. 更好用的提交列表
        *   1.2.8\. 更好的差异比较
        *   1.2.9\. 工作进度保存
        *   1.2.10\. 代理 SVN 提交实现移动式办公
        *   1.2.11\. 无处不在的分页器
        *   1.2.12\. 快
    *   1.3\. 安装 Git
        *   1.3.1\. Linux 下安装和使用 Git
            *   1.3.1.1\. 包管理器方式安装
            *   1.3.1.2\. 从源代码开始安装
            *   1.3.1.3\. 从 Git 版本库进行安装
            *   1.3.1.4\. 命令补齐
            *   1.3.1.5\. 中文支持
        *   1.3.2\. Mac OS X 下安装和使用 Git
            *   1.3.2.1\. 以二进制发布包的形式安装
            *   1.3.2.2\. 安装 Xcode
            *   1.3.2.3\. 使用 Homebrew 安装 Git
            *   1.3.2.4\. 从 Git 源码进行安装
            *   1.3.2.5\. 命令自动补齐
            *   1.3.2.6\. 其他辅助工具的安装
            *   1.3.2.7\. 中文支持
        *   1.3.3\. Windows 下安装和使用 Git（Cygwin 篇）
            *   1.3.3.1\. 安装 Cygwin
            *   1.3.3.2\. 安装 Git
            *   1.3.3.3\. Cygwin 的配置和使用
            *   1.3.3.4\. Cygwin 下 Git 的中文支持
            *   1.3.3.5\. Cygwin 下 Git 访问 SSH 服务
        *   1.3.4\. Windows 下安装和使用 Git（msysGit 篇）
            *   1.3.4.1\. 安装 msysGit
            *   1.3.4.2\. msysGit 的配置和使用
            *   1.3.4.3\. msysGit 的 shell 环境的中文支持
            *   1.3.4.4\. msysGit 中 Git 的中文支持
            *   1.3.4.5\. 使用 SSH 协议
            *   1.3.4.6\. TortoiseGit 的安装和使用
            *   1.3.4.7\. TortoiseGit 的中文支持
*   2\. Git 独奏
    *   2.1\. Git 初始化
        *   2.1.1\. 创建版本库及第一次提交
        *   2.1.2\. 思考：为什么工作区下有一个`.git`目录？
        *   2.1.3\. 思考：**git config**命令参数的区别？
        *   2.1.4\. 思考：是谁完成的提交？
        *   2.1.5\. 思考：随意设置提交者姓名，是否太不安全？
        *   2.1.6\. 思考：命令别名是干什么的？
        *   2.1.7\. 备份本章的工作成果
    *   2.2\. Git 暂存区
        *   2.2.1\. 修改不能直接提交？
        *   2.2.2\. 理解 Git 暂存区（stage）
        *   2.2.3\. Git Diff 魔法
        *   2.2.4\. 不要使用**git commit -a**
        *   2.2.5\. 搁置问题，暂存状态
    *   2.3\. Git 对象
        *   2.3.1\. Git 对象库探秘
        *   2.3.2\. 问题：SHA1 哈希值到底是什么，如何生成的？
        *   2.3.3\. 问题：为什么不用顺序的数字来表示提交？
    *   2.4\. Git 重置
        *   2.4.1\. 分支游标 master 的探秘
        *   2.4.2\. 用 reflog 挽救错误的重置
        *   2.4.3\. 深入了解**git reset**命令
    *   2.5\. Git 检出
        *   2.5.1\. HEAD 的重置即检出
        *   2.5.2\. 挽救分离头指针
        *   2.5.3\. 深入了解**git checkout**命令
    *   2.6\. 恢复进度
        *   2.6.1\. 继续暂存区未完成的实践
        *   2.6.2\. 使用**git stash**
        *   2.6.3\. 探秘**git stash**
    *   2.7\. Git 基本操作
        *   2.7.1\. 先来合个影
        *   2.7.2\. 删除文件
            *   2.7.2.1\. 本地删除不是真的删除
            *   2.7.2.2\. 执行**git rm**命令删除文件
            *   2.7.2.3\. 命令**git add -u**快速标记删除
        *   2.7.3\. 恢复删除的文件
        *   2.7.4\. 移动文件
        *   2.7.5\. 一个显示版本号的`Hello World`
        *   2.7.6\. 使用**git add -i**选择性添加
        *   2.7.7\. `Hello world`引发的新问题
        *   2.7.8\. 文件忽略
        *   2.7.9\. 文件归档
    *   2.8\. 历史穿梭
        *   2.8.1\. 图形工具：gitk
        *   2.8.2\. 图形工具：gitg
        *   2.8.3\. 图形工具：qgit
        *   2.8.4\. 命令行工具
            *   2.8.4.1\. 版本表示法：**git rev-parse**
            *   2.8.4.2\. 版本范围表示法：git rev-list
            *   2.8.4.3\. 浏览日志：**git log**
            *   2.8.4.4\. 差异比较：**git diff**
            *   2.8.4.5\. 文件追溯：**git blame**
            *   2.8.4.6\. 二分查找：**git bisect**
            *   2.8.4.7\. 获取历史版本
    *   2.9\. 改变历史
        *   2.9.1\. 悔棋
        *   2.9.2\. 多步悔棋
        *   2.9.3\. 回到未来
            *   2.9.3.1\. 时间旅行一
            *   2.9.3.2\. 时间旅行二
            *   2.9.3.3\. 时间旅行三
        *   2.9.4\. 丢弃历史
        *   2.9.5\. 反转提交
    *   2.10\. Git 克隆
        *   2.10.1\. 鸡蛋不装在一个篮子里
        *   2.10.2\. 对等工作区
        *   2.10.3\. 克隆生成裸版本库
        *   2.10.4\. 创建生成裸版本库
    *   2.11\. Git 库管理
        *   2.11.1\. 对象和引用哪里去了？
        *   2.11.2\. 暂存区操作引入的临时对象
        *   2.11.3\. 重置操作引入的对象
        *   2.11.4\. Git 管家：`git gc`
        *   2.11.5\. Git 管家的自动执行
*   3\. Git 和声
    *   3.1\. Git 协议与工作协同
        *   3.1.1\. Git 支持的协议
        *   3.1.2\. 多用户协同的本地模拟
        *   3.1.3\. 强制非快进式推送
        *   3.1.4\. 合并后推送
        *   3.1.5\. 禁止非快进式推送
    *   3.2\. 冲突解决
        *   3.2.1\. 拉回操作中的合并
        *   3.2.2\. 合并一：自动合并
            *   3.2.2.1\. 修改不同的文件
            *   3.2.2.2\. 修改相同文件的不同区域
            *   3.2.2.3\. 同时更改文件名和文件内容
        *   3.2.3\. 合并二：逻辑冲突
        *   3.2.4\. 合并三：冲突解决
            *   3.2.4.1\. 手工编辑完成冲突解决
            *   3.2.4.2\. 图形工具完成冲突解决
        *   3.2.5\. 合并四：树冲突
            *   3.2.5.1\. 手工操作解决树冲突
            *   3.2.5.2\. 交互式解决树冲突
        *   3.2.6\. 合并策略
        *   3.2.7\. 合并相关的设置
    *   3.3\. Git 里程碑
        *   3.3.1\. 显示里程碑
            *   3.3.1.1\. 1\. 命令**git tag**
            *   3.3.1.2\. 2\. 命令**git log**
            *   3.3.1.3\. 3\. 命令**git describe**
            *   3.3.1.4\. 4\. 命令**git name-rev**
        *   3.3.2\. 创建里程碑
            *   3.3.2.1\. 轻量级里程碑
            *   3.3.2.2\. 带说明的里程碑
            *   3.3.2.3\. 带签名的里程碑
        *   3.3.3\. 删除里程碑
        *   3.3.4\. 不要随意更改里程碑
        *   3.3.5\. 共享里程碑
        *   3.3.6\. 删除远程版本库的里程碑
        *   3.3.7\. 里程碑命名规范
    *   3.4\. Git 分支
        *   3.4.1\. 代码管理之殇
            *   3.4.1.1\. 发布分支
            *   3.4.1.2\. 特性分支
            *   3.4.1.3\. 卖主分支
        *   3.4.2\. 分支命令概述
        *   3.4.3\. Hello World 开发计划
        *   3.4.4\. 基于特性分支的开发
            *   3.4.4.1\. 创建分支`user1/getopt`
            *   3.4.4.2\. 创建分支`user2/i18n`
            *   3.4.4.3\. 开发者 user1 完成功能开发
            *   3.4.4.4\. 将`user1/getopt`分支合并到主线
        *   3.4.5\. 基于发布分支的开发
            *   3.4.5.1\. 创建发布分支
            *   3.4.5.2\. 开发者 user1 工作在发布分支
            *   3.4.5.3\. 开发者 user2 工作在发布分支
            *   3.4.5.4\. 开发者 user2 合并推送
            *   3.4.5.5\. 发布分支的提交合并到主线
        *   3.4.6\. 分支变基
            *   3.4.6.1\. 完成`user2/i18n`特性分支的开发
            *   3.4.6.2\. 分支`user2/i18n`变基
    *   3.5\. 远程版本库
        *   3.5.1\. 远程分支
        *   3.5.2\. 分支追踪
        *   3.5.3\. 远程版本库
        *   3.5.4\. PUSH 和 PULL 操作与远程版本库
        *   3.5.5\. 里程碑和远程版本库
        *   3.5.6\. 分支和里程碑的安全性
    *   3.6\. 补丁文件交互
        *   3.6.1\. 创建补丁
        *   3.6.2\. 应用补丁
        *   3.6.3\. StGit 和 Quilt
            *   3.6.3.1\. StGit
            *   3.6.3.2\. Quilt
*   4\. Git 协同模型
    *   4.1\. 经典 Git 协同模型
        *   4.1.1\. 集中式协同模型
            *   4.1.1.1\. 使用集中协同模型
            *   4.1.1.2\. Gerrit 特殊的集中协同模型
    *   4.2\. 金字塔式协同模型
        *   4.2.1\. 贡献者开放只读版本库
        *   4.2.2\. 以补丁方式贡献代码
    *   4.3\. Topgit 协同模型
        *   4.3.1\. 作者版本控制系统三个里程碑
        *   4.3.2\. Topgit 原理
        *   4.3.3\. Topgit 的安装
        *   4.3.4\. Topgit 的使用
            *   4.3.4.1\. **tg help**命令
            *   4.3.4.2\. **tg create**命令
            *   4.3.4.3\. **tg info**命令
            *   4.3.4.4\. **tg update**命令
            *   4.3.4.5\. **tg summary**命令
            *   4.3.4.6\. **tg remote**命令
            *   4.3.4.7\. **tg push**命令
            *   4.3.4.8\. **tg depend**命令
            *   4.3.4.9\. **tg base**命令
            *   4.3.4.10\. **tg delete**命令
            *   4.3.4.11\. **tg patch**命令
            *   4.3.4.12\. **tg export**命令
            *   4.3.4.13\. **tg import**命令
            *   4.3.4.14\. **tg log**命令
            *   4.3.4.15\. **tg mail**命令
            *   4.3.4.16\. **tg graph**命令
        *   4.3.5\. Topgit hacks
        *   4.3.6\. Topgit 使用中的注意事项
    *   4.4\. 子模组协同模型
        *   4.4.1\. 创建子模组
        *   4.4.2\. 克隆带子模组的版本库
        *   4.4.3\. 在子模组中修改和子模组的更新
        *   4.4.4\. 隐性子模组
        *   4.4.5\. 子模组的管理问题
    *   4.5\. 子树合并
        *   4.5.1\. 引入外部版本库
        *   4.5.2\. 子目录方式合并外部版本库
        *   4.5.3\. 利用子树合并跟踪上游改动
        *   4.5.4\. 子树拆分
        *   4.5.5\. `git subtree`插件
            *   4.5.5.1\. **git subtree add**
            *   4.5.5.2\. **git subtree merge**
            *   4.5.5.3\. **git subtree pull**
            *   4.5.5.4\. **git subtree split**
            *   4.5.5.5\. **git subtree push**
    *   4.6\. Android 式多版本库协同
        *   4.6.1\. 关于 repo
        *   4.6.2\. 安装 repo
        *   4.6.3\. repo 和清单库的初始化
        *   4.6.4\. 清单库和清单文件
        *   4.6.5\. 同步项目
        *   4.6.6\. 建立 Android 代码库本地镜像
        *   4.6.7\. Repo 的命令集
            *   4.6.7.1\. **repo init**命令
            *   4.6.7.2\. **repo sync**命令
            *   4.6.7.3\. **repo start**命令
            *   4.6.7.4\. **repo status**命令
            *   4.6.7.5\. **repo checkout**命令
            *   4.6.7.6\. **repo branches**命令
            *   4.6.7.7\. **repo diff**命令
            *   4.6.7.8\. **repo stage**命令
            *   4.6.7.9\. **repo upload**命令
            *   4.6.7.10\. **repo download**命令
            *   4.6.7.11\. **repo rebase**命令
            *   4.6.7.12\. **repo prune**命令
            *   4.6.7.13\. **repo abandon**命令
            *   4.6.7.14\. 其他命令
        *   4.6.8\. Repo 命令的工作流
        *   4.6.9\. 好东西不能 Android 独享
            *   4.6.9.1\. Repo+Gerrit 模式
            *   4.6.9.2\. Repo 无审核模式
            *   4.6.9.3\. 改进的 Repo 无审核模式
    *   4.7\. Git 和 SVN 协同模型
        *   4.7.1\. 使用 git-svn 的一般流程
        *   4.7.2\. git-svn 的奥秘
            *   4.7.2.1\. Git 库配置文件的扩展及分支映射
            *   4.7.2.2\. Git 工作分支和 Subversion 如何对应？
            *   4.7.2.3\. 其他辅助文件
        *   4.7.3\. 多样的 git-svn 克隆模式
        *   4.7.4\. 共享 git-svn 的克隆库
        *   4.7.5\. git-svn 的局限
*   5\. 搭建 Git 服务器
    *   5.1\. 使用 HTTP 协议
        *   5.1.1\. 哑传输协议
        *   5.1.2\. 智能 HTTP 协议
        *   5.1.3\. Gitweb 服务器
            *   5.1.3.1\. Gitweb 安装
            *   5.1.3.2\. Gitweb 配置
            *   5.1.3.3\. 版本库的 Gitweb 相关设置
    *   5.2\. 使用 Git 协议
        *   5.2.1\. Git 协议语法格式
        *   5.2.2\. Git 服务软件
        *   5.2.3\. 以 inetd 方式配置运行
        *   5.2.4\. 以 runit 方式配置运行
    *   5.3\. 使用 SSH 协议
        *   5.3.1\. SSH 协议语法格式
        *   5.3.2\. 服务架设方式比较
        *   5.3.3\. 关于 SSH 公钥认证
        *   5.3.4\. 关于 SSH 主机别名
    *   5.4\. Gitolite 服务架设
        *   5.4.1\. 安装 Gitolite
            *   5.4.1.1\. 安装之前
            *   5.4.1.2\. 以发布包形式安装
            *   5.4.1.3\. 从源代码开始安装
        *   5.4.2\. 管理 Gitolite
            *   5.4.2.1\. 管理员克隆 gitolite-admin 管理库
            *   5.4.2.2\. 增加新用户
            *   5.4.2.3\. 更改授权
        *   5.4.3\. Gitolite 授权详解
            *   5.4.3.1\. 授权文件的基本语法
            *   5.4.3.2\. 定义用户组和版本库组
            *   5.4.3.3\. 版本库 ACL
            *   5.4.3.4\. Gitolite 授权机制
        *   5.4.4\. 版本库授权案例
            *   5.4.4.1\. 常规版本库授权
            *   5.4.4.2\. 通配符版本库授权
            *   5.4.4.3\. 每个人创建自己的版本库
            *   5.4.4.4\. 传统模式的引用授权
            *   5.4.4.5\. 扩展模式的引用授权
            *   5.4.4.6\. 禁用规则的使用
            *   5.4.4.7\. 用户分支
            *   5.4.4.8\. 对路径的写授权
        *   5.4.5\. 创建和导入版本库
            *   5.4.5.1\. 在配置文件中出现的版本库，即时生成
            *   5.4.5.2\. 通配符版本库，管理员通过推送创建
            *   5.4.5.3\. 向 Gitolite 中导入版本库
        *   5.4.6\. 对 Gitolite 的改进
        *   5.4.7\. Gitolite 功能拓展
            *   5.4.7.1\. 版本库镜像
            *   5.4.7.2\. Gitweb 和 Git daemon 支持
            *   5.4.7.3\. 其他功能拓展和参考
    *   5.5\. Gitosis 服务架设
        *   5.5.1\. 安装 Gitosis
            *   5.5.1.1\. Gitosis 的安装
            *   5.5.1.2\. 服务器端创建专用帐号
            *   5.5.1.3\. Gitosis 服务初始化
        *   5.5.2\. 管理 Gitosis
            *   5.5.2.1\. 管理员克隆`gitolit-admin`管理库
            *   5.5.2.2\. 增加新用户
            *   5.5.2.3\. 更改授权
        *   5.5.3\. Gitosis 授权详解
            *   5.5.3.1\. Gitosis 缺省设置
            *   5.5.3.2\. 管理版本库`gitosis-admin`
            *   5.5.3.3\. 定义用户组和授权
            *   5.5.3.4\. Gitweb 整合
        *   5.5.4\. 创建新版本库
        *   5.5.5\. 轻量级管理的 Git 服务
    *   5.6\. Gerrit 代码审核服务器
        *   5.6.1\. Gerrit 的实现原理
            *   5.6.1.1\. SSH 协议的 Git 服务器
            *   5.6.1.2\. 特殊引用`refs/for/<branch-name>`和`refs/changes/nn/<review-id>/m`
            *   5.6.1.3\. Git 库的钩子脚本`hooks/commit-msg`
            *   5.6.1.4\. 其余一切交给 Web
        *   5.6.2\. 架设 Gerrit 的服务器
        *   5.6.3\. Gerrit 的配置文件
        *   5.6.4\. Gerrit 的数据库访问
        *   5.6.5\. 立即注册为 Gerrit 管理员
        *   5.6.6\. 管理员访问 SSH 的管理接口
        *   5.6.7\. 创建新项目
        *   5.6.8\. 从已有 Git 库创建项目
        *   5.6.9\. 定义评审工作流
        *   5.6.10\. Gerrit 评审工作流实战
            *   5.6.10.1\. 开发者在本地版本库中工作
            *   5.6.10.2\. 开发者向审核服务器提交
            *   5.6.10.3\. 审核评审任务
            *   5.6.10.4\. 评审任务没有通过测试
            *   5.6.10.5\. 重新提交新的补丁集
            *   5.6.10.6\. 新修订集通过评审
            *   5.6.10.7\. 从远程版本库更新
        *   5.6.11\. 更多 Gerrit 参考
    *   5.7\. Git 版本库托管
        *   5.7.1\. Github
        *   5.7.2\. Gitorious
*   6\. 迁移到 Git
    *   6.1\. CVS 版本库到 Git 的迁移
        *   6.1.1\. 安装 cvs2svn（含 cvs2git）
        *   6.1.2\. 版本库转换（命令行参数模式）
        *   6.1.3\. 版本库转换（配置文件模式）
        *   6.1.4\. 迁移后版本库检查
            *   6.1.4.1\. 文件名和日志的中文
            *   6.1.4.2\. 图片文件被破坏
            *   6.1.4.3\. `.cvsignore`文件的转换
            *   6.1.4.4\. 迁移后的测试
    *   6.2\. 更多版本控制系统的迁移
        *   6.2.1\. SVN 版本库到 Git 的迁移
        *   6.2.2\. Hg 版本库到 Git 的迁移
        *   6.2.3\. 通用版本库迁移
        *   6.2.4\. Git 版本库整理
            *   6.2.4.1\. 环境变量过滤器
            *   6.2.4.2\. 树过滤器
            *   6.2.4.3\. 暂存区过滤器
            *   6.2.4.4\. 父节点过滤器
            *   6.2.4.5\. 提交说明过滤器
            *   6.2.4.6\. 提交过滤器
            *   6.2.4.7\. 里程碑名字过滤器
            *   6.2.4.8\. 子目录过滤器
*   7\. Git 的其它应用
    *   7.1\. etckeeper
        *   7.1.1\. 安装 etckeeper
        *   7.1.2\. 配置 etckeeper
        *   7.1.3\. 使用 etckeeper
    *   7.2\. Gistore
        *   7.2.1\. Gistore 的安装
            *   7.2.1.1\. 从源码安装 Gistore
            *   7.2.1.2\. 用`easy_install`安装
        *   7.2.2\. Gistore 的使用
            *   7.2.2.1\. 创建并初始化备份库
            *   7.2.2.2\. Gistore 的配置文件
            *   7.2.2.3\. Gistore 的备份项管理
            *   7.2.2.4\. 执行备份任务
            *   7.2.2.5\. 查看备份日志及数据
            *   7.2.2.6\. 查看及恢复备份数据
            *   7.2.2.7\. 备份回滚及设置
            *   7.2.2.8\. 注册备份任务别名
            *   7.2.2.9\. 自动备份：crontab
        *   7.2.3\. Gistore 双机备份
    *   7.3\. 补丁中的二进制文件
        *   7.3.1\. Git 版本库中二进制文件变更的支持
        *   7.3.2\. 对非 Git 版本库中二进制文件变更的支持
        *   7.3.3\. 其他工具对 Git 扩展补丁文件的支持
    *   7.4\. 云存储
        *   7.4.1\. 现有云存储的问题
        *   7.4.2\. Git 式云存储畅想
*   8\. Git 杂谈
    *   8.1\. 跨平台操作 Git
        *   8.1.1\. 字符集问题
        *   8.1.2\. 文件名大小写问题
        *   8.1.3\. 换行符问题
    *   8.2\. Git 的其他特性
        *   8.2.1\. 属性
            *   8.2.1.1\. 属性定义
            *   8.2.1.2\. 属性文件及优先级
            *   8.2.1.3\. 常用属性介绍
        *   8.2.2\. 钩子和模板
            *   8.2.2.1\. Git 钩子
            *   8.2.2.2\. Git 模板
        *   8.2.3\. 稀疏检出和浅克隆
            *   8.2.3.1\. 稀疏检出
            *   8.2.3.2\. 浅克隆
        *   8.2.4\. 嫁接和替换
            *   8.2.4.1\. 提交嫁接
            *   8.2.4.2\. 提交替换
        *   8.2.5\. Git 评注
            *   8.2.5.1\. 评注的奥秘
            *   8.2.5.2\. 评注相关命令
            *   8.2.5.3\. 评注相关配置
*   9\. 附录
    *   9.1\. A. Git 命令索引
        *   9.1.1\. A.1 常用的 Git 命令
        *   9.1.2\. A.2 对象库操作相关命令
        *   9.1.3\. A.3 引用操作相关命令
        *   9.1.4\. A.4 版本库管理相关命令
        *   9.1.5\. A.5 数据传输相关命令
        *   9.1.6\. A.6 邮件相关命令
        *   9.1.7\. A.7 协议相关命令
        *   9.1.8\. A.8 版本库转换和交互相关命令
        *   9.1.9\. A.9 合并相关的辅助命令
        *   9.1.10\. A.10 杂项
    *   9.2\. Git 与 CVS 面对面
        *   9.2.1\. 面对面访谈录
        *   9.2.2\. CVS 和 Git 命令对照
    *   9.3\. Git 和 SVN 面对面
        *   9.3.1\. 面对面访谈录
        *   9.3.2\. SVN 和 Git 命令对照
    *   9.4\. Git 和 Hg 面对面
        *   9.4.1\. 面对面访谈录
        *   9.4.2\. Hg 和 Git 命令对照

# Indices and tables

*   Index
*   Search Page

© Copyright 2011, 蒋鑫. Created using [Sphinx](http://sphinx-doc.org/) 1.3.4.